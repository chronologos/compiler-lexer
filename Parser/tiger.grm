structure a = Absyn
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  exp | program | decs | dec | decsOpt | tydec | vardec | fundec | ty | tyfields | tyfieldsOne |  tyfieldscommaOpt | varDecOpt | fundecOpts | lvalue | lvalueOpt | fundecs | tydecs

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)
decs: dec decs (dec :: decs)
     | ([])

dec: tydecs (a.TypeDec(tydecs)) 
   | vardec (a.VarDec(vardec))
   | fundecs (a.FunctionDec(fundecs))


tydecs: tydec tydecs (tydec::tydecs)
	| ([])

tydec: TYPE ID EQ ty ({name=a.symbol(ID), ty=ty, pos=0})

ty : ID (a.NameTy(a.symbol(ID), 0))
   | LBRACE tyfields RBRACE (a.RecordTy(tyfields))
   | ARRAY OF ID (a.symbol(ID), 0)

tyfieldsOne : ID COLON ID([{name = a.symbol(ID1), escape = ref false, typ = a.symbol(ID2), pos = 0}] )

tyfields : tyfieldsOne tyfieldscommaOpt ( tyfieldsOne :: tyfieldscommaOpt)
	   | ([]) 

tyfieldscommaOpt: COMMA tyfieldsOne tyfieldscommaOpt (tyfieldsOne :: tyfieldscommaOpt)
             | ([])


vardec : VAR ID varDecOpt ({name = a.symbol(ID), escape = ref false, typ = #typ varDecOpt, init = #init varDecOpt, pos = 0})

varDecOpt:  ASSIGN exp ({typ = NONE, init = exp})
          | COLON ID ASSIGN exp ({typ = SOME(a.symbol(ID), 0), init = exp })

fundecs : fundec fundecs ( fundec :: fundecs )
   | ([])

fundec : FUNCTION ID LPAREN tyfields RPAREN fundecOpts ({name= a.symbol(ID), params=tyfields, result = #result fundecOpts, body = #body fundecOpts, pos = 0})

fundecOpts : EQ exp ({body = exp, result = NONE})
	     | COLON ID EQ exp ({body = exp, result = SOME(a.symbol(ID), 0)})


lvalue : ID lvalueOpt ()
	
lvalueOpt : DOT ID lvalueOpt ()
          | LBRACK exp RBRACK lvalueOpt ()
	    | ()


exp : INT (a.IntExp(INT))
    | decs (a.LetExp(decs,body=a.IntExp(1),pos=0))

program: exp (exp)
