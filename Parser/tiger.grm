structure A = Absyn
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  exp | program | decs | dec | decsOpt | tydec | vardec | fundec | ty | tyfields | tyfieldsOne |  tyfieldscommaOpt | varDecOpt | fundecOpts | lvalue | lvalueOpt | fundecs | tydecs | seqexp | seqexpOpt | seqexpOpt2

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)
decs: dec decs (dec :: decs)
     | ([])

dec: tydecs (A.TypeDec(tydecs)) 
   | vardec (A.VarDec(vardec))
   | fundecs (A.FunctionDec(fundecs))


tydecs: tydecs tydec (tydec::tydecs)
	| tydec ([tydec])

tydec: TYPE ID EQ ty ({name=A.symbol(ID), ty=ty, pos=0})

ty : ID (A.NameTy(A.symbol(ID), 0))
   | LBRACE tyfields RBRACE (A.RecordTy(tyfields))
   | ARRAY OF ID (A.symbol(ID), 0)

tyfieldsOne : ID COLON ID({name = A.symbol(ID1), escape = ref false, typ = A.symbol(ID2), pos = 0})

tyfields : tyfieldsOne tyfieldscommaOpt ( tyfieldsOne :: tyfieldscommaOpt)
	   | ([]) 

tyfieldscommaOpt: COMMA tyfieldsOne tyfieldscommaOpt (tyfieldsOne :: tyfieldscommaOpt)
             | ([])


vardec : VAR ID varDecOpt ({name = A.symbol(ID), escape = ref false, typ = #typ varDecOpt, init = #init varDecOpt, pos = 0})

varDecOpt:  ASSIGN exp ({typ = NONE, init = exp})
          | COLON ID ASSIGN exp ({typ = SOME(A.symbol(ID), 0), init = exp })

fundecs : fundecs fundec ( fundec :: fundecs )
   | fundec ([fundec])

fundec : FUNCTION ID LPAREN tyfields RPAREN fundecOpts ({name= A.symbol(ID), params=tyfields, result = #result fundecOpts, body = #body fundecOpts, pos = 0})

fundecOpts : EQ exp ({body = exp, result = NONE})
	     | COLON ID EQ exp ({body = exp, result = SOME(A.symbol(ID), 0)})


lvalue : ID lvalueOpt ()
	
lvalueOpt : DOT ID lvalueOpt ()
          | LBRACK exp RBRACK lvalueOpt ()
	    | ()

seqexp : LPAREN exp SEMICOLON exp seqexpOpt ()
seqexpOpt: RPAREN ()
     	    | seqexpOpt2 seqexpOpt ()
seqexpOpt2 : SEMICOLON exp seqexpOpt2  ()
		|  ()

exp : INT (a.IntExp(INT))
    | LET decs IN seqexp END ()

program: exp (exp)
