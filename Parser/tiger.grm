structure A = Absyn
structure S = Symbol
type symbol = S.symbol
val symbol = S.symbol

type field = {name: symbol, escape: bool ref, typ: symbol, pos: A.pos}
type fundec = {name: symbol, params: field list, result: (symbol * A.pos) option, body: A.exp, pos: A.pos}
type pos = A.pos
type exp = A.exp

fun toFieldVar (var, id, pos) = A.FieldVar(var,id,pos)
fun toSubscriptVar (var,exp,pos) = A.SubscriptVar(var,exp,pos)

fun toVarExp (head,list) =
  case list of
      ((SOME exp, NONE, pos)::l) => toVarExp(toSubscriptVar(head,exp,pos),l)
     |((NONE,SOME id,pos)::l)  => toVarExp(toFieldVar(head,id,pos),l) 
     | [] => head 
%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | UMINUS | IFTHEN | LOWEST

%nonterm
  exp of A.exp
| program of A.exp
| decs of A.dec list
| dec of A.dec
| tydec of {name: symbol, ty: A.ty, pos: A.pos}
| tydecs of {name: symbol, ty: A.ty, pos: A.pos} list
| vardec of {name: symbol, escape: bool ref, typ: (symbol * A.pos) option, init: A.exp, pos: A.pos}
| fundec of fundec
| fundecs of fundec list
| ty of A.ty
| tyfields of field list
| tyfieldsOne of field
| tyfieldscommaOpt of field list
| varDecOpt of {typ: (symbol * A.pos) option, init: A.exp}
| fundecOpts of {body : A.exp, result : (symbol * pos) option}
| lvalue of A.var
| seqexpOpt of (A.exp * A.pos) list
| seqexp of A.exp
| letSeqExp of (A.exp * A.pos) list
| recordExp of A.exp
| recordExpOpt of (symbol * exp * pos) list 
| funCallExpList of A.exp list
| assignExp of A.exp
| ifExpOpt of A.exp option
| ifExp of A.exp
| funCallExpListOpt of A.exp list
| whileExp of A.exp
| forExp of A.exp
| breakExp of A.exp
| arrayDecExp of A.exp
| lvalueOpt of (A.exp option * symbol option * int) list
     
%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN


%value ID ("bogus")
%value INT (1)
%value STRING ("")

%nonassoc ID OF
%nonassoc LBRACE RBRACE LBRACK RBRACK
%nonassoc WHILE DO
%nonassoc IFTHEN
%nonassoc IF THEN ELSE
%nonassoc ASSIGN 
%left AND OR 
%nonassoc EQ NEQ LE GE GT LT
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%


program: exp (exp)
	     
exp : INT (A.IntExp(INT))
    | NIL (A.NilExp)
    | STRING (A.StringExp(STRING, STRINGleft))
    | exp PLUS exp (A.OpExp({left=exp1, oper= A.PlusOp, right=exp2, pos=PLUSleft}))
    | exp TIMES exp (A.OpExp({left=exp1, oper= A.TimesOp, right=exp2,pos=TIMESleft}))
    | exp EQ exp (A.OpExp({left=exp1, oper= A.EqOp, right=exp2,pos=EQleft}))
    | exp NEQ exp (A.OpExp({left=exp1, oper= A.NeqOp, right=exp2,pos=NEQleft}))
    | exp GT exp (A.OpExp({left=exp1, oper= A.GtOp, right=exp2,pos=GTleft}))
    | exp GE exp (A.OpExp({left=exp1, oper= A.GeOp, right=exp2,pos=GEleft}))
    | exp LE exp (A.OpExp({left=exp1, oper= A.LeOp, right=exp2,pos=LEleft}))
    | exp LT exp (A.OpExp({left=exp1, oper= A.LtOp, right=exp2,pos=LTleft}))
    | exp AND exp (A.IfExp({test=exp1,then'=exp2,else'=SOME(A.IntExp(0)) ,pos=ANDleft}))
    | exp OR exp (A.IfExp({test=exp1,then'=A.IntExp(1),else'=SOME(exp2) ,pos=ORleft}))
    | exp DIVIDE exp (A.OpExp({left=exp1, oper= A.DivideOp, right=exp2,pos=DIVIDEleft}))
    | exp MINUS exp (A.OpExp({left=exp1, oper= A.MinusOp, right=exp2,pos=MINUSleft})) 
    | MINUS exp %prec UMINUS (A.OpExp({left=A.IntExp(0),oper=A.MinusOp,right=exp1,pos=MINUSleft}))
    | recordExp (recordExp)
    | lvalue (A.VarExp(lvalue))
    | ifExp (ifExp)
    | assignExp (assignExp)
    | ID LPAREN funCallExpList RPAREN (A.CallExp({func=symbol(ID), args=funCallExpList, pos=IDleft }))
    | seqexp (seqexp)
    | LET decs IN exp letSeqExp END (A.LetExp({decs = decs, body = A.SeqExp((exp,expleft)::letSeqExp), pos = LETleft}))
    | whileExp (whileExp)
    | forExp (forExp)
    | breakExp (breakExp)
    | arrayDecExp (arrayDecExp)
	     
recordExpOpt: ([])
    | COMMA ID EQ exp recordExpOpt ((symbol(ID),exp,IDleft)::recordExpOpt)
			    
recordExp: ID LBRACE RBRACE (A.RecordExp({fields=[],typ=symbol(ID),pos=IDleft}))
	 | ID LBRACE ID EQ exp recordExpOpt RBRACE (A.RecordExp({fields=(symbol(ID2),exp,ID2left)::recordExpOpt,typ=symbol(ID1),pos=ID1left}))

ifExp: IF exp THEN exp ELSE exp (A.IfExp({test=exp1,then'=exp2,else'=SOME(exp3),pos=IFleft}))
     | IF exp THEN exp %prec IFTHEN (A.IfExp({test=exp1,then'=exp2,else'=NONE,pos=IFleft}))

lvalue: ID lvalueOpt			 (toVarExp(A.SimpleVar(symbol(ID),IDleft),lvalueOpt))
lvalueOpt: DOT ID lvalueOpt		 ((NONE,SOME(symbol(ID)),DOTleft)::lvalueOpt)
	 | LBRACK exp RBRACK lvalueOpt 	 ((SOME(exp),NONE,LBRACKleft)::lvalueOpt)
	 | ([])

assignExp: lvalue ASSIGN exp (A.AssignExp({var=lvalue,exp=exp,pos=ASSIGNleft}))
		     
funCallExpList: ([])
          | exp funCallExpListOpt (exp :: funCallExpListOpt)

funCallExpListOpt: COMMA exp funCallExpListOpt (exp :: funCallExpListOpt)
		 | ([])
seqexp: LPAREN exp seqexpOpt (A.SeqExp((exp,expleft)::seqexpOpt))

seqexpOpt: RPAREN ([])
     	 | SEMICOLON exp seqexpOpt ((exp,expleft)::seqexpOpt)
		     
letSeqExp: SEMICOLON exp letSeqExp ((exp,expleft)::letSeqExp)
	 | SEMICOLON ([])
	 | ([])

arrayDecExp: ID LBRACK exp RBRACK OF exp (A.ArrayExp({typ=symbol(ID),size=exp1,init=exp2,pos=IDleft}))

whileExp: WHILE exp DO exp (A.WhileExp({test=exp1,body=exp2,pos=WHILEleft}))

breakExp: BREAK (A.BreakExp(BREAKleft))

forExp: FOR ID ASSIGN exp TO exp DO exp (A.ForExp({var=symbol(ID),escape=ref false,lo=exp1,hi=exp2,body=exp3,pos=FORleft}))
	       
decs: dec decs (dec :: decs)
     | ([])

dec: tydecs (A.TypeDec(tydecs))
   | vardec (A.VarDec(vardec))
   | fundecs (A.FunctionDec(fundecs))


tydecs: tydecs tydec (tydecs @ [tydec])
      | tydec ([tydec])

tydec: TYPE ID EQ ty ({name=S.symbol(ID), ty=ty, pos=TYPEleft})

ty : ID (A.NameTy(S.symbol(ID), IDleft))
   | LBRACE tyfields RBRACE (A.RecordTy(tyfields))
   | ARRAY OF ID (A.ArrayTy(S.symbol(ID), ARRAYleft))

tyfieldsOne : ID COLON ID({name = S.symbol(ID1), escape = ref false, typ = S.symbol(ID2), pos = IDleft})

tyfields : tyfieldsOne tyfieldscommaOpt ( tyfieldsOne :: tyfieldscommaOpt)
	   | ([])

tyfieldscommaOpt: COMMA tyfieldsOne tyfieldscommaOpt (tyfieldsOne :: tyfieldscommaOpt)
             | ([])


vardec : VAR ID varDecOpt ({name = S.symbol(ID), escape = ref false, typ = #typ varDecOpt, init = #init varDecOpt, pos = VARleft})

varDecOpt:  ASSIGN exp ({typ = NONE, init = exp})
          | COLON ID ASSIGN exp ({typ = SOME(S.symbol(ID), COLONleft), init = exp })

fundecs : fundecs fundec ( fundecs @ [fundec] )
   | fundec ([fundec])

fundec : FUNCTION ID LPAREN tyfields RPAREN fundecOpts ({name= S.symbol(ID), params=tyfields, result = #result fundecOpts, body = #body fundecOpts, pos = fundecOptsleft})

fundecOpts : EQ exp ({body = exp, result = NONE})
	     | COLON ID EQ exp ({body = exp, result = SOME(S.symbol(ID), COLONleft)})
		     
